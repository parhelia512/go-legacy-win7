From a6100b9ca51b3057934d5b0b60e5dafc89b34d80 Mon Sep 17 00:00:00 2001
From: Vorapol Rinsatitnon <vorapol.r@pm.me>
Date: Thu, 12 Feb 2026 01:39:37 +0700
Subject: [PATCH] Restore GOPATH-mode get

---
 src/cmd/go/alldocs.go             |  66 +++
 src/cmd/go/internal/get/get.go    | 642 ++++++++++++++++++++++++++++++
 src/cmd/go/internal/help/help.go  |   8 +
 src/cmd/go/internal/load/pkg.go   |  60 +++
 src/cmd/go/internal/modget/get.go |  17 +
 src/cmd/go/internal/vcs/vcs.go    | 362 ++++++++++++++++-
 src/cmd/go/main.go                |  11 +
 src/cmd/internal/par/work.go      |  38 ++
 8 files changed, 1187 insertions(+), 17 deletions(-)
 create mode 100644 src/cmd/go/internal/get/get.go

diff --git a/src/cmd/go/alldocs.go b/src/cmd/go/alldocs.go
index 8c346da..8fe3da2 100644
--- a/src/cmd/go/alldocs.go
+++ b/src/cmd/go/alldocs.go
@@ -47,9 +47,11 @@
 //	goauth          GOAUTH environment variable
 //	go.mod          the go.mod file
 //	gopath          GOPATH environment variable
+//	gopath-get      legacy GOPATH go get
 //	goproxy         module proxy protocol
 //	importpath      import path syntax
 //	modules         modules, module versions, and more
+//	module-get      module-aware go get
 //	module-auth     module authentication using go.sum
 //	packages        package lists and patterns
 //	private         configuration for downloading non-public code
@@ -2885,6 +2887,70 @@
 //
 // See https://golang.org/s/go15vendor for details.
 //
+// # Legacy GOPATH go get
+//
+// The 'go get' command changes behavior depending on whether the
+// go command is running in module-aware mode or legacy GOPATH mode.
+// This help text, accessible as 'go help gopath-get' even in module-aware mode,
+// describes 'go get' as it operates in legacy GOPATH mode.
+//
+// Usage: go get [-d] [-f] [-t] [-u] [-v] [-fix] [build flags] [packages]
+//
+// Get downloads the packages named by the import paths, along with their
+// dependencies. It then installs the named packages, like 'go install'.
+//
+// The -d flag instructs get to stop after downloading the packages; that is,
+// it instructs get not to install the packages.
+//
+// The -f flag, valid only when -u is set, forces get -u not to verify that
+// each package has been checked out from the source control repository
+// implied by its import path. This can be useful if the source is a local fork
+// of the original.
+//
+// The -fix flag instructs get to run the fix tool on the downloaded packages
+// before resolving dependencies or building the code.
+//
+// The -t flag instructs get to also download the packages required to build
+// the tests for the specified packages.
+//
+// The -u flag instructs get to use the network to update the named packages
+// and their dependencies. By default, get uses the network to check out
+// missing packages but does not use it to look for updates to existing packages.
+//
+// The -v flag enables verbose progress and debug output.
+//
+// Get also accepts build flags to control the installation. See 'go help build'.
+//
+// When checking out a new package, get creates the target directory
+// GOPATH/src/<import-path>. If the GOPATH contains multiple entries,
+// get uses the first one. For more details see: 'go help gopath'.
+//
+// When checking out or updating a package, get looks for a branch or tag
+// that matches the locally installed version of Go. The most important
+// rule is that if the local installation is running version "go1", get
+// searches for a branch or tag named "go1". If no such version exists
+// it retrieves the default branch of the package.
+//
+// When go get checks out or updates a Git repository,
+// it also updates any git submodules referenced by the repository.
+//
+// Get never checks out or updates code stored in vendor directories.
+//
+// For more about build flags, see 'go help build'.
+//
+// For more about specifying packages, see 'go help packages'.
+//
+// For more about how 'go get' finds source code to
+// download, see 'go help importpath'.
+//
+// This text describes the behavior of get when using GOPATH
+// to manage source code and dependencies.
+// If instead the go command is running in module-aware mode,
+// the details of get's flags and effects change, as does 'go help get'.
+// See 'go help modules' and 'go help module-get'.
+//
+// See also: go build, go install, go clean.
+//
 // # Module proxy protocol
 //
 // A Go module proxy is any web server that can respond to GET requests for
diff --git a/src/cmd/go/internal/get/get.go b/src/cmd/go/internal/get/get.go
new file mode 100644
index 0000000..c3aca82
--- /dev/null
+++ b/src/cmd/go/internal/get/get.go
@@ -0,0 +1,642 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package get implements the “go get” command.
+package get
+
+import (
+	"context"
+	"fmt"
+	"os"
+	"path/filepath"
+	"runtime"
+	"strings"
+
+	"cmd/go/internal/base"
+	"cmd/go/internal/cfg"
+	"cmd/go/internal/load"
+	"cmd/go/internal/modload"
+	"cmd/go/internal/search"
+	"cmd/go/internal/str"
+	"cmd/go/internal/vcs"
+	"cmd/go/internal/web"
+	"cmd/go/internal/work"
+
+	"golang.org/x/mod/module"
+)
+
+var CmdGet = &base.Command{
+	UsageLine: "go get [-d] [-f] [-t] [-u] [-v] [-fix] [build flags] [packages]",
+	Short:     "download and install packages and dependencies",
+	Long: `
+Get downloads the packages named by the import paths, along with their
+dependencies. It then installs the named packages, like 'go install'.
+
+The -d flag instructs get to stop after downloading the packages; that is,
+it instructs get not to install the packages.
+
+The -f flag, valid only when -u is set, forces get -u not to verify that
+each package has been checked out from the source control repository
+implied by its import path. This can be useful if the source is a local fork
+of the original.
+
+The -fix flag instructs get to run the fix tool on the downloaded packages
+before resolving dependencies or building the code.
+
+The -t flag instructs get to also download the packages required to build
+the tests for the specified packages.
+
+The -u flag instructs get to use the network to update the named packages
+and their dependencies. By default, get uses the network to check out
+missing packages but does not use it to look for updates to existing packages.
+
+The -v flag enables verbose progress and debug output.
+
+Get also accepts build flags to control the installation. See 'go help build'.
+
+When checking out a new package, get creates the target directory
+GOPATH/src/<import-path>. If the GOPATH contains multiple entries,
+get uses the first one. For more details see: 'go help gopath'.
+
+When checking out or updating a package, get looks for a branch or tag
+that matches the locally installed version of Go. The most important
+rule is that if the local installation is running version "go1", get
+searches for a branch or tag named "go1". If no such version exists
+it retrieves the default branch of the package.
+
+When go get checks out or updates a Git repository,
+it also updates any git submodules referenced by the repository.
+
+Get never checks out or updates code stored in vendor directories.
+
+For more about build flags, see 'go help build'.
+
+For more about specifying packages, see 'go help packages'.
+
+For more about how 'go get' finds source code to
+download, see 'go help importpath'.
+
+This text describes the behavior of get when using GOPATH
+to manage source code and dependencies.
+If instead the go command is running in module-aware mode,
+the details of get's flags and effects change, as does 'go help get'.
+See 'go help modules' and 'go help module-get'.
+
+See also: go build, go install, go clean.
+	`,
+}
+
+var HelpGopathGet = &base.Command{
+	UsageLine: "gopath-get",
+	Short:     "legacy GOPATH go get",
+	Long: `
+The 'go get' command changes behavior depending on whether the
+go command is running in module-aware mode or legacy GOPATH mode.
+This help text, accessible as 'go help gopath-get' even in module-aware mode,
+describes 'go get' as it operates in legacy GOPATH mode.
+
+Usage: ` + CmdGet.UsageLine + `
+` + CmdGet.Long,
+}
+
+var (
+	getD        = CmdGet.Flag.Bool("d", false, "")
+	getF        = CmdGet.Flag.Bool("f", false, "")
+	getT        = CmdGet.Flag.Bool("t", false, "")
+	getU        = CmdGet.Flag.Bool("u", false, "")
+	getFix      = CmdGet.Flag.Bool("fix", false, "")
+	getInsecure = CmdGet.Flag.Bool("insecure", false, "")
+)
+
+func init() {
+	work.AddBuildFlags(CmdGet, work.OmitModFlag|work.OmitModCommonFlags)
+	CmdGet.Run = runGet // break init loop
+}
+
+func runGet(ctx context.Context, cmd *base.Command, args []string) {
+	if cfg.ModulesEnabled {
+		// Should not happen: main.go should install the separate module-enabled get code.
+		base.Fatalf("go: modules not implemented")
+	}
+
+	moduleLoaderState := modload.NewState()
+
+	work.BuildInit(moduleLoaderState)
+
+	if *getF && !*getU {
+		base.Fatalf("go: cannot use -f flag without -u")
+	}
+	if *getInsecure {
+		base.Fatalf("go: -insecure flag is no longer supported; use GOINSECURE instead")
+	}
+
+	// Disable any prompting for passwords by Git itself.
+	// Only has an effect for 2.3.0 or later, but avoiding
+	// the prompt in earlier versions is just too hard.
+	// If user has explicitly set GIT_TERMINAL_PROMPT=1, keep
+	// prompting.
+	// See golang.org/issue/9341 and golang.org/issue/12706.
+	if os.Getenv("GIT_TERMINAL_PROMPT") == "" {
+		os.Setenv("GIT_TERMINAL_PROMPT", "0")
+	}
+
+	// Also disable prompting for passwords by the 'ssh' subprocess spawned by
+	// Git, because apparently GIT_TERMINAL_PROMPT isn't sufficient to do that.
+	// Adding '-o BatchMode=yes' should do the trick.
+	//
+	// If a Git subprocess forks a child into the background to cache a new connection,
+	// that child keeps stdout/stderr open. After the Git subprocess exits,
+	// os /exec expects to be able to read from the stdout/stderr pipe
+	// until EOF to get all the data that the Git subprocess wrote before exiting.
+	// The EOF doesn't come until the child exits too, because the child
+	// is holding the write end of the pipe.
+	// This is unfortunate, but it has come up at least twice
+	// (see golang.org/issue/13453 and golang.org/issue/16104)
+	// and confuses users when it does.
+	// If the user has explicitly set GIT_SSH or GIT_SSH_COMMAND,
+	// assume they know what they are doing and don't step on it.
+	// But default to turning off ControlMaster.
+	if os.Getenv("GIT_SSH") == "" && os.Getenv("GIT_SSH_COMMAND") == "" {
+		os.Setenv("GIT_SSH_COMMAND", "ssh -o ControlMaster=no -o BatchMode=yes")
+	}
+
+	// And one more source of Git prompts: the Git Credential Manager Core for Windows.
+	//
+	// See https://github.com/microsoft/Git-Credential-Manager-Core/blob/master/docs/environment.md#gcm_interactive.
+	if os.Getenv("GCM_INTERACTIVE") == "" {
+		os.Setenv("GCM_INTERACTIVE", "never")
+	}
+
+	// Phase 1. Download/update.
+	var stk load.ImportStack
+	mode := 0
+	if *getT {
+		mode |= load.GetTestDeps
+	}
+	for _, pkg := range downloadPaths(args) {
+		download(moduleLoaderState, ctx, pkg, nil, &stk, mode)
+	}
+	base.ExitIfErrors()
+
+	// Phase 2. Rescan packages and re-evaluate args list.
+
+	// Code we downloaded and all code that depends on it
+	// needs to be evicted from the package cache so that
+	// the information will be recomputed. Instead of keeping
+	// track of the reverse dependency information, evict
+	// everything.
+	load.ClearPackageCache()
+
+	pkgs := load.PackagesAndErrors(moduleLoaderState, ctx, load.PackageOpts{}, args)
+	load.CheckPackageErrors(pkgs)
+
+	// Phase 3. Install.
+	if *getD {
+		// Download only.
+		// Check delayed until now so that downloadPaths
+		// and CheckPackageErrors have a chance to print errors.
+		return
+	}
+
+	work.InstallPackages(moduleLoaderState, ctx, args, pkgs)
+}
+
+// downloadPaths prepares the list of paths to pass to download.
+// It expands ... patterns that can be expanded. If there is no match
+// for a particular pattern, downloadPaths leaves it in the result list,
+// in the hope that we can figure out the repository from the
+// initial ...-free prefix.
+func downloadPaths(patterns []string) []string {
+	for _, arg := range patterns {
+		if strings.Contains(arg, "@") {
+			base.Fatalf("go: can only use path@version syntax with 'go get' and 'go install' in module-aware mode")
+		}
+
+		// Guard against 'go get x.go', a common mistake.
+		// Note that package and module paths may end with '.go', so only print an error
+		// if the argument has no slash or refers to an existing file.
+		if strings.HasSuffix(arg, ".go") {
+			if !strings.Contains(arg, "/") {
+				base.Errorf("go: %s: arguments must be package or module paths", arg)
+				continue
+			}
+			if fi, err := os.Stat(arg); err == nil && !fi.IsDir() {
+				base.Errorf("go: %s exists as a file, but 'go get' requires package arguments", arg)
+			}
+		}
+	}
+	base.ExitIfErrors()
+
+	var pkgs []string
+	for _, m := range search.ImportPathsQuiet(patterns) {
+		if len(m.Pkgs) == 0 && strings.Contains(m.Pattern(), "...") {
+			pkgs = append(pkgs, m.Pattern())
+		} else {
+			pkgs = append(pkgs, m.Pkgs...)
+		}
+	}
+	return pkgs
+}
+
+// downloadCache records the import paths we have already
+// considered during the download, to avoid duplicate work when
+// there is more than one dependency sequence leading to
+// a particular package.
+var downloadCache = map[string]bool{}
+
+// downloadRootCache records the version control repository
+// root directories we have already considered during the download.
+// For example, all the packages in the github.com/google/codesearch repo
+// share the same root (the directory for that path), and we only need
+// to run the hg commands to consider each repository once.
+var downloadRootCache = map[string]bool{}
+
+// download runs the download half of the get command
+// for the package or pattern named by the argument.
+func download(moduleLoaderState *modload.State, ctx context.Context, arg string, parent *load.Package, stk *load.ImportStack, mode int) {
+	if mode&load.ResolveImport != 0 {
+		// Caller is responsible for expanding vendor paths.
+		panic("internal error: download mode has useVendor set")
+	}
+	load1 := func(path string, mode int) *load.Package {
+		if parent == nil {
+			mode := 0 // don't do module or vendor resolution
+			return load.LoadPackage(moduleLoaderState, ctx, load.PackageOpts{}, path, base.Cwd(), stk, nil, mode)
+		}
+		p, err := load.LoadImport(moduleLoaderState, ctx, load.PackageOpts{}, path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)
+		if err != nil {
+			base.Errorf("%s", err)
+		}
+		return p
+	}
+
+	p := load1(arg, mode)
+	if p.Error != nil && p.Error.Hard {
+		base.Errorf("%s", p.Error)
+		return
+	}
+
+	// loadPackage inferred the canonical ImportPath from arg.
+	// Use that in the following to prevent hysteresis effects
+	// in e.g. downloadCache and packageCache.
+	// This allows invocations such as:
+	//   mkdir -p $GOPATH/src/github.com/user
+	//   cd $GOPATH/src/github.com/user
+	//   go get ./foo
+	// see: golang.org/issue/9767
+	arg = p.ImportPath
+
+	// There's nothing to do if this is a package in the standard library.
+	if p.Standard {
+		return
+	}
+
+	// Only process each package once.
+	// (Unless we're fetching test dependencies for this package,
+	// in which case we want to process it again.)
+	if downloadCache[arg] && mode&load.GetTestDeps == 0 {
+		return
+	}
+	downloadCache[arg] = true
+
+	pkgs := []*load.Package{p}
+	wildcardOkay := len(*stk) == 0
+	isWildcard := false
+
+	// Download if the package is missing, or update if we're using -u.
+	if p.Dir == "" || *getU {
+		// The actual download.
+		stk.Push(load.ImportInfo{Pkg: arg})
+		err := downloadPackage(p)
+		if err != nil {
+			base.Errorf("%s", &load.PackageError{ImportStack: stk.Copy(), Err: err})
+			stk.Pop()
+			return
+		}
+		stk.Pop()
+
+		args := []string{arg}
+		// If the argument has a wildcard in it, re-evaluate the wildcard.
+		// We delay this until after reloadPackage so that the old entry
+		// for p has been replaced in the package cache.
+		if wildcardOkay && strings.Contains(arg, "...") {
+			match := search.NewMatch(arg)
+			if match.IsLocal() {
+				noModRoots := []string{} // We're in gopath mode, so there are no modroots.
+				match.MatchDirs(noModRoots)
+				args = match.Dirs
+			} else {
+				match.MatchPackages()
+				args = match.Pkgs
+			}
+			for _, err := range match.Errs {
+				base.Errorf("%s", err)
+			}
+			isWildcard = true
+		}
+
+		// Clear all relevant package cache entries before
+		// doing any new loads.
+		load.ClearPackageCachePartial(args)
+
+		pkgs = pkgs[:0]
+		for _, arg := range args {
+			// Note: load calls loadPackage or loadImport,
+			// which push arg onto stk already.
+			// Do not push here too, or else stk will say arg imports arg.
+			p := load1(arg, mode)
+			if p.Error != nil {
+				base.Errorf("%s", p.Error)
+				continue
+			}
+			pkgs = append(pkgs, p)
+		}
+	}
+
+	// Process package, which might now be multiple packages
+	// due to wildcard expansion.
+	for _, p := range pkgs {
+		if *getFix {
+			files := base.RelPaths(p.InternalAllGoFiles())
+			base.Run(cfg.BuildToolexec, str.StringList(base.Tool("fix"), files))
+
+			// The imports might have changed, so reload again.
+			p = load.ReloadPackageNoFlags(arg, stk)
+			if p.Error != nil {
+				base.Errorf("%s", p.Error)
+				return
+			}
+		}
+
+		if isWildcard {
+			// Report both the real package and the
+			// wildcard in any error message.
+			stk.Push(load.ImportInfo{Pkg: p.ImportPath})
+		}
+
+		// Process dependencies, now that we know what they are.
+		imports := p.Imports
+		if mode&load.GetTestDeps != 0 {
+			// Process test dependencies when -t is specified.
+			// (But don't get test dependencies for test dependencies:
+			// we always pass mode 0 to the recursive calls below.)
+			imports = str.StringList(imports, p.TestImports, p.XTestImports)
+		}
+		for i, path := range imports {
+			if path == "C" {
+				continue
+			}
+			// Fail fast on import naming full vendor path.
+			// Otherwise expand path as needed for test imports.
+			// Note that p.Imports can have additional entries beyond p.Internal.Build.Imports.
+			orig := path
+			if i < len(p.Internal.Build.Imports) {
+				orig = p.Internal.Build.Imports[i]
+			}
+			if j, ok := load.FindVendor(orig); ok {
+				stk.Push(load.ImportInfo{Pkg: path})
+				err := &load.PackageError{
+					ImportStack: stk.Copy(),
+					Err:         load.ImportErrorf(path, "%s must be imported as %s", path, path[j+len("vendor/"):]),
+				}
+				stk.Pop()
+				base.Errorf("%s", err)
+				continue
+			}
+			// If this is a test import, apply module and vendor lookup now.
+			// We cannot pass ResolveImport to download, because
+			// download does caching based on the value of path,
+			// so it must be the fully qualified path already.
+			if i >= len(p.Imports) {
+				path = load.ResolveImportPath(moduleLoaderState, p, path)
+			}
+			download(moduleLoaderState, ctx, path, p, stk, 0)
+		}
+
+		if isWildcard {
+			stk.Pop()
+		}
+	}
+}
+
+// downloadPackage runs the create or download command
+// to make the first copy of or update a copy of the given package.
+func downloadPackage(p *load.Package) error {
+	var (
+		vcsCmd                  *vcs.Cmd
+		repo, rootPath, repoDir string
+		err                     error
+		blindRepo               bool // set if the repo has unusual configuration
+	)
+
+	// p can be either a real package, or a pseudo-package whose “import path” is
+	// actually a wildcard pattern.
+	// Trim the path at the element containing the first wildcard,
+	// and hope that it applies to the wildcarded parts too.
+	// This makes 'go get rsc.io/pdf/...' work in a fresh GOPATH.
+	importPrefix := p.ImportPath
+	if i := strings.Index(importPrefix, "..."); i >= 0 {
+		slash := strings.LastIndexByte(importPrefix[:i], '/')
+		if slash < 0 {
+			return fmt.Errorf("cannot expand ... in %q", p.ImportPath)
+		}
+		importPrefix = importPrefix[:slash]
+	}
+	if err := checkImportPath(importPrefix); err != nil {
+		return fmt.Errorf("%s: invalid import path: %v", p.ImportPath, err)
+	}
+	security := web.SecureOnly
+	if module.MatchPrefixPatterns(cfg.GOINSECURE, importPrefix) {
+		security = web.Insecure
+	}
+
+	if p.Internal.Build.SrcRoot != "" {
+		// Directory exists. Look for checkout along path to src.
+
+		repoDir, vcsCmd, err = vcs.FromDir(p.Dir, p.Internal.Build.SrcRoot)
+		if err != nil {
+			return err
+		}
+		if !str.HasFilePathPrefix(repoDir, p.Internal.Build.SrcRoot) {
+			panic(fmt.Sprintf("repository %q not in source root %q", repo, p.Internal.Build.SrcRoot))
+		}
+		rootPath = str.TrimFilePathPrefix(repoDir, p.Internal.Build.SrcRoot)
+		if err := vcs.CheckGOVCS(vcsCmd, rootPath); err != nil {
+			return err
+		}
+
+		repo = "<local>" // should be unused; make distinctive
+
+		// Double-check where it came from.
+		if *getU && vcsCmd.RemoteRepo != nil {
+			dir := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))
+			remote, err := vcsCmd.RemoteRepo(vcsCmd, dir)
+			if err != nil {
+				// Proceed anyway. The package is present; we likely just don't understand
+				// the repo configuration (e.g. unusual remote protocol).
+				blindRepo = true
+			}
+			repo = remote
+			if !*getF && err == nil {
+				if rr, err := vcs.RepoRootForImportPath(importPrefix, vcs.IgnoreMod, security); err == nil {
+					repo := rr.Repo
+					if rr.VCS.ResolveRepo != nil {
+						resolved, err := rr.VCS.ResolveRepo(rr.VCS, dir, repo)
+						if err == nil {
+							repo = resolved
+						}
+					}
+					if remote != repo && rr.IsCustom {
+						return fmt.Errorf("%s is a custom import path for %s, but %s is checked out from %s", rr.Root, repo, dir, remote)
+					}
+				}
+			}
+		}
+	} else {
+		// Analyze the import path to determine the version control system,
+		// repository, and the import path for the root of the repository.
+		rr, err := vcs.RepoRootForImportPath(importPrefix, vcs.IgnoreMod, security)
+		if err != nil {
+			return err
+		}
+		vcsCmd, repo, rootPath = rr.VCS, rr.Repo, rr.Root
+	}
+	if !blindRepo && !vcsCmd.IsSecure(repo) && security != web.Insecure {
+		return fmt.Errorf("cannot download: %v uses insecure protocol", repo)
+	}
+
+	if p.Internal.Build.SrcRoot == "" {
+		// Package not found. Put in first directory of $GOPATH.
+		list := filepath.SplitList(cfg.BuildContext.GOPATH)
+		if len(list) == 0 {
+			return fmt.Errorf("cannot download: $GOPATH not set. For more details see: 'go help gopath'")
+		}
+		// Guard against people setting GOPATH=$GOROOT.
+		if filepath.Clean(list[0]) == filepath.Clean(cfg.GOROOT) {
+			return fmt.Errorf("cannot download: $GOPATH must not be set to $GOROOT. For more details see: 'go help gopath'")
+		}
+		if _, err := os.Stat(filepath.Join(list[0], "src/cmd/go/alldocs.go")); err == nil {
+			return fmt.Errorf("cannot download: %s is a GOROOT, not a GOPATH. For more details see: 'go help gopath'", list[0])
+		}
+		p.Internal.Build.Root = list[0]
+		p.Internal.Build.SrcRoot = filepath.Join(list[0], "src")
+		p.Internal.Build.PkgRoot = filepath.Join(list[0], "pkg")
+	}
+	root := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))
+
+	if err := vcs.CheckNested(vcsCmd, root, p.Internal.Build.SrcRoot); err != nil {
+		return err
+	}
+
+	// If we've considered this repository already, don't do it again.
+	if downloadRootCache[root] {
+		return nil
+	}
+	downloadRootCache[root] = true
+
+	if cfg.BuildV {
+		fmt.Fprintf(os.Stderr, "%s (download)\n", rootPath)
+	}
+
+	// Check that this is an appropriate place for the repo to be checked out.
+	// The target directory must either not exist or have a repo checked out already.
+	meta := filepath.Join(root, "."+vcsCmd.Cmd)
+	if _, err := os.Stat(meta); err != nil {
+		// Metadata file or directory does not exist. Prepare to checkout new copy.
+		// Some version control tools require the target directory not to exist.
+		// We require that too, just to avoid stepping on existing work.
+		if _, err := os.Stat(root); err == nil {
+			return fmt.Errorf("%s exists but %s does not - stale checkout?", root, meta)
+		}
+
+		_, err := os.Stat(p.Internal.Build.Root)
+		gopathExisted := err == nil
+
+		// Some version control tools require the parent of the target to exist.
+		parent, _ := filepath.Split(root)
+		if err = os.MkdirAll(parent, 0777); err != nil {
+			return err
+		}
+		if cfg.BuildV && !gopathExisted && p.Internal.Build.Root == cfg.BuildContext.GOPATH {
+			fmt.Fprintf(os.Stderr, "created GOPATH=%s; see 'go help gopath'\n", p.Internal.Build.Root)
+		}
+
+		if err = vcsCmd.Create(root, repo); err != nil {
+			return err
+		}
+	} else {
+		// Metadata directory does exist; download incremental updates.
+		if err = vcsCmd.Download(root); err != nil {
+			return err
+		}
+	}
+
+	if cfg.BuildN {
+		// Do not show tag sync in -n; it's noise more than anything,
+		// and since we're not running commands, no tag will be found.
+		// But avoid printing nothing.
+		fmt.Fprintf(os.Stderr, "# cd %s; %s sync/update\n", root, vcsCmd.Cmd)
+		return nil
+	}
+
+	// Select and sync to appropriate version of the repository.
+	tags, err := vcsCmd.Tags(root)
+	if err != nil {
+		return err
+	}
+	vers := runtime.Version()
+	if i := strings.Index(vers, " "); i >= 0 {
+		vers = vers[:i]
+	}
+	if err := vcsCmd.TagSync(root, selectTag(vers, tags)); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// selectTag returns the closest matching tag for a given version.
+// Closest means the latest one that is not after the current release.
+// Version "goX" (or "goX.Y" or "goX.Y.Z") matches tags of the same form.
+// Version "release.rN" matches tags of the form "go.rN" (N being a floating-point number).
+// Version "weekly.YYYY-MM-DD" matches tags like "go.weekly.YYYY-MM-DD".
+//
+// NOTE(rsc): Eventually we will need to decide on some logic here.
+// For now, there is only "go1". This matches the docs in go help get.
+func selectTag(goVersion string, tags []string) (match string) {
+	for _, t := range tags {
+		if t == "go1" {
+			return "go1"
+		}
+	}
+	return ""
+}
+
+// checkImportPath is like module.CheckImportPath, but it forbids leading dots
+// in path elements. This can lead to 'go get' creating .git and other VCS
+// directories in places we might run VCS tools later.
+func checkImportPath(path string) error {
+	if err := module.CheckImportPath(path); err != nil {
+		return err
+	}
+	checkElem := func(elem string) error {
+		if elem[0] == '.' {
+			return fmt.Errorf("malformed import path %q: leading dot in path element", path)
+		}
+		return nil
+	}
+	elemStart := 0
+	for i, r := range path {
+		if r == '/' {
+			if err := checkElem(path[elemStart:]); err != nil {
+				return err
+			}
+			elemStart = i + 1
+		}
+	}
+	if err := checkElem(path[elemStart:]); err != nil {
+		return err
+	}
+	return nil
+}
diff --git a/src/cmd/go/internal/help/help.go b/src/cmd/go/internal/help/help.go
index 4f2607f..cdb7350 100644
--- a/src/cmd/go/internal/help/help.go
+++ b/src/cmd/go/internal/help/help.go
@@ -16,6 +16,7 @@ import (
 	"unicode/utf8"
 
 	"cmd/go/internal/base"
+	"cmd/go/internal/modload"
 	"cmd/internal/telemetry/counter"
 )
 
@@ -36,7 +37,14 @@ func Help(w io.Writer, args []string) {
 		PrintUsage(buf, base.Go)
 		usage := &base.Command{Long: buf.String()}
 		cmds := []*base.Command{usage}
+		s := modload.NewState()
 		for _, cmd := range base.Go.Commands {
+			// Avoid duplication of the "get" documentation.
+			if cmd.UsageLine == "module-get" && s.Enabled() {
+				continue
+			} else if cmd.UsageLine == "gopath-get" && !s.Enabled() {
+				continue
+			}
 			cmds = append(cmds, cmd)
 			cmds = append(cmds, cmd.Commands...)
 		}
diff --git a/src/cmd/go/internal/load/pkg.go b/src/cmd/go/internal/load/pkg.go
index e2a77d7..cca3d00 100644
--- a/src/cmd/go/internal/load/pkg.go
+++ b/src/cmd/go/internal/load/pkg.go
@@ -456,6 +456,7 @@ type PackageError struct {
 	Pos              string      // position of error
 	Err              error       // the error itself
 	IsImportCycle    bool        // the error is an import cycle
+	Hard             bool        // whether the error is soft or hard; soft errors are ignored in some places
 	alwaysPrintStack bool        // whether to always print the ImportStack
 }
 
@@ -635,6 +636,51 @@ func (sp *ImportStack) shorterThan(t []string) bool {
 // we return the same pointer each time.
 var packageCache = map[string]*Package{}
 
+// ClearPackageCache clears the in-memory package cache and the preload caches.
+// It is only for use by GOPATH-based "go get".
+// TODO(jayconrod): When GOPATH-based "go get" is removed, delete this function.
+func ClearPackageCache() {
+	clear(packageCache)
+	resolvedImportCache.Clear()
+	packageDataCache.Clear()
+}
+
+// ClearPackageCachePartial clears packages with the given import paths from the
+// in-memory package cache and the preload caches. It is only for use by
+// GOPATH-based "go get".
+// TODO(jayconrod): When GOPATH-based "go get" is removed, delete this function.
+func ClearPackageCachePartial(args []string) {
+	shouldDelete := make(map[string]bool)
+	for _, arg := range args {
+		shouldDelete[arg] = true
+		if p := packageCache[arg]; p != nil {
+			delete(packageCache, arg)
+		}
+	}
+	resolvedImportCache.DeleteIf(func(key importSpec) bool {
+		return shouldDelete[key.path]
+	})
+	packageDataCache.DeleteIf(func(key string) bool {
+		return shouldDelete[key]
+	})
+}
+
+// ReloadPackageNoFlags is like LoadImport but makes sure
+// not to use the package cache.
+// It is only for use by GOPATH-based "go get".
+// TODO(rsc): When GOPATH-based "go get" is removed, delete this function.
+func ReloadPackageNoFlags(arg string, stk *ImportStack) *Package {
+	p := packageCache[arg]
+	if p != nil {
+		delete(packageCache, arg)
+		resolvedImportCache.DeleteIf(func(key importSpec) bool {
+			return key.path == p.ImportPath
+		})
+		packageDataCache.Delete(p.ImportPath)
+	}
+	return LoadPackage(modload.NewState(), context.TODO(), PackageOpts{}, arg, base.Cwd(), stk, nil, 0)
+}
+
 // dirToImportPath returns the pseudo-import path we use for a package
 // outside the Go path. It begins with _/ and then contains the full path
 // to the directory. If the package lives in c:\home\gopher\my\pkg then
@@ -686,6 +732,20 @@ const (
 	cmdlinePkgLiteral
 )
 
+// LoadImport scans the directory named by path, which must be an import path,
+// but possibly a local import path (an absolute file system path or one beginning
+// with ./ or ../). A local relative path is interpreted relative to srcDir.
+// It returns a *Package describing the package found in that directory.
+// LoadImport does not set tool flags and should only be used by
+// this package, as part of a bigger load operation, and by GOPATH-based "go get".
+// TODO(rsc): When GOPATH-based "go get" is removed, unexport this function.
+// The returned PackageError, if any, describes why parent is not allowed
+// to import the named package, with the error referring to importPos.
+// The PackageError can only be non-nil when parent is not nil.
+func LoadImport(loaderstate *modload.State, ctx context.Context, opts PackageOpts, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) (*Package, *PackageError) {
+	return loadImport(loaderstate, ctx, opts, nil, path, srcDir, parent, stk, importPos, mode)
+}
+
 // LoadPackage does Load import, but without a parent package load context
 func LoadPackage(loaderstate *modload.State, ctx context.Context, opts PackageOpts, path, srcDir string, stk *ImportStack, importPos []token.Position, mode int) *Package {
 	p, err := loadImport(loaderstate, ctx, opts, nil, path, srcDir, nil, stk, importPos, mode)
diff --git a/src/cmd/go/internal/modget/get.go b/src/cmd/go/internal/modget/get.go
index b731ccc..75ffac6 100644
--- a/src/cmd/go/internal/modget/get.go
+++ b/src/cmd/go/internal/modget/get.go
@@ -129,6 +129,23 @@ See also: go build, go install, go clean, go mod.
 	`,
 }
 
+// Note that this help text is a stopgap to make the module-aware get help text
+// available even in non-module settings. It should be deleted when the old get
+// is deleted. It should NOT be considered to set a precedent of having hierarchical
+// help names with dashes.
+var HelpModuleGet = &base.Command{
+	UsageLine: "module-get",
+	Short:     "module-aware go get",
+	Long: `
+The 'go get' command changes behavior depending on whether the
+go command is running in module-aware mode or legacy GOPATH mode.
+This help text, accessible as 'go help module-get' even in legacy GOPATH mode,
+describes 'go get' as it operates in module-aware mode.
+
+Usage: ` + CmdGet.UsageLine + `
+` + CmdGet.Long,
+}
+
 var HelpVCS = &base.Command{
 	UsageLine: "vcs",
 	Short:     "controlling version control with GOVCS",
diff --git a/src/cmd/go/internal/vcs/vcs.go b/src/cmd/go/internal/vcs/vcs.go
index 9e8efaf..d9eaaf2 100644
--- a/src/cmd/go/internal/vcs/vcs.go
+++ b/src/cmd/go/internal/vcs/vcs.go
@@ -17,6 +17,7 @@ import (
 	"os"
 	"os/exec"
 	"path/filepath"
+	"regexp"
 	"strconv"
 	"strings"
 	"sync"
@@ -40,10 +41,20 @@ type Cmd struct {
 	Env       []string   // any environment values to set/override
 	RootNames []rootName // filename and mode indicating the root of a checkout directory
 
+	CreateCmd   []string // commands to download a fresh copy of a repository
+	DownloadCmd []string // commands to download updates into an existing repository
+
+	TagCmd         []tagCmd // commands to list tags
+	TagLookupCmd   []tagCmd // commands to lookup tags before running tagSyncCmd
+	TagSyncCmd     []string // commands to sync to specific tag
+	TagSyncDefault []string // commands to sync to default tag
+
 	Scheme  []string
 	PingCmd string
 
-	Status func(v *Cmd, rootDir string) (Status, error)
+	RemoteRepo  func(v *Cmd, rootDir string) (remoteRepo string, err error)
+	ResolveRepo func(v *Cmd, rootDir, remoteRepo string) (realRepo string, err error)
+	Status      func(v *Cmd, rootDir string) (Status, error)
 }
 
 // Status is the current state of a local repository.
@@ -153,9 +164,33 @@ var vcsHg = &Cmd{
 		{filename: ".hg", isDir: true},
 	},
 
-	Scheme:  []string{"https", "http", "ssh"},
-	PingCmd: "identify -- {scheme}://{repo}",
-	Status:  hgStatus,
+	CreateCmd:   []string{"clone -U -- {repo} {dir}"},
+	DownloadCmd: []string{"pull"},
+
+	// We allow both tag and branch names as 'tags'
+	// for selecting a version. This lets people have
+	// a go.release.r60 branch and a go1 branch
+	// and make changes in both, without constantly
+	// editing .hgtags.
+	TagCmd: []tagCmd{
+		{"tags", `^(\S+)`},
+		{"branches", `^(\S+)`},
+	},
+	TagSyncCmd:     []string{"update -r {tag}"},
+	TagSyncDefault: []string{"update default"},
+
+	Scheme:     []string{"https", "http", "ssh"},
+	PingCmd:    "identify -- {scheme}://{repo}",
+	RemoteRepo: hgRemoteRepo,
+	Status:     hgStatus,
+}
+
+func hgRemoteRepo(vcsHg *Cmd, rootDir string) (remoteRepo string, err error) {
+	out, err := vcsHg.runOutput(rootDir, "paths default")
+	if err != nil {
+		return "", err
+	}
+	return strings.TrimSpace(string(out)), nil
 }
 
 func hgStatus(vcsHg *Cmd, rootDir string) (Status, error) {
@@ -218,6 +253,25 @@ var vcsGit = &Cmd{
 		{filename: ".git", isDir: true},
 	},
 
+	CreateCmd:   []string{"clone -- {repo} {dir}", "--go-internal-cd {dir} submodule update --init --recursive"},
+	DownloadCmd: []string{"pull --ff-only", "submodule update --init --recursive"},
+
+	TagCmd: []tagCmd{
+		// tags/xxx matches a git tag named xxx
+		// origin/xxx matches a git branch named xxx on the default remote repository
+		{"show-ref", `(?:tags|origin)/(\S+)$`},
+	},
+	TagLookupCmd: []tagCmd{
+		{"show-ref tags/{tag} origin/{tag}", `((?:tags|origin)/\S+)$`},
+	},
+	TagSyncCmd: []string{"checkout {tag}", "submodule update --init --recursive"},
+	// both createCmd and downloadCmd update the working dir.
+	// No need to do more here. We used to 'checkout master'
+	// but that doesn't work if the default branch is not named master.
+	// DO NOT add 'checkout master' here.
+	// See golang.org/issue/9032.
+	TagSyncDefault: []string{"submodule update --init --recursive"},
+
 	Scheme: []string{"git", "https", "http", "git+ssh", "ssh"},
 
 	// Leave out the '--' separator in the ls-remote command: git 2.7.4 does not
@@ -226,7 +280,54 @@ var vcsGit = &Cmd{
 	// See golang.org/issue/33836.
 	PingCmd: "ls-remote {scheme}://{repo}",
 
-	Status: gitStatus,
+	RemoteRepo: gitRemoteRepo,
+	Status:     gitStatus,
+}
+
+// scpSyntaxRe matches the SCP-like addresses used by Git to access
+// repositories by SSH.
+var scpSyntaxRe = lazyregexp.New(`^(\w+)@([\w.-]+):(.*)$`)
+
+func gitRemoteRepo(vcsGit *Cmd, rootDir string) (remoteRepo string, err error) {
+	const cmd = "config remote.origin.url"
+	outb, err := vcsGit.run1(rootDir, cmd, nil, false)
+	if err != nil {
+		// if it doesn't output any message, it means the config argument is correct,
+		// but the config value itself doesn't exist
+		if outb != nil && len(outb) == 0 {
+			return "", errors.New("remote origin not found")
+		}
+		return "", err
+	}
+	out := strings.TrimSpace(string(outb))
+
+	var repoURL *urlpkg.URL
+	if m := scpSyntaxRe.FindStringSubmatch(out); m != nil {
+		// Match SCP-like syntax and convert it to a URL.
+		// Eg, "git@github.com:user/repo" becomes
+		// "ssh://git@github.com/user/repo".
+		repoURL = &urlpkg.URL{
+			Scheme: "ssh",
+			User:   urlpkg.User(m[1]),
+			Host:   m[2],
+			Path:   m[3],
+		}
+	} else {
+		repoURL, err = urlpkg.Parse(out)
+		if err != nil {
+			return "", err
+		}
+	}
+
+	// Iterate over insecure schemes too, because this function simply
+	// reports the state of the repo. If we can't see insecure schemes then
+	// we can't report the actual repo URL.
+	for _, s := range vcsGit.Scheme {
+		if repoURL.Scheme == s {
+			return repoURL.String(), nil
+		}
+	}
+	return "", errors.New("unable to parse output of git " + cmd)
 }
 
 func gitStatus(vcsGit *Cmd, rootDir string) (Status, error) {
@@ -266,9 +367,62 @@ var vcsBzr = &Cmd{
 		{filename: ".bzr", isDir: true},
 	},
 
-	Scheme:  []string{"https", "http", "bzr", "bzr+ssh"},
-	PingCmd: "info -- {scheme}://{repo}",
-	Status:  bzrStatus,
+	CreateCmd: []string{"branch -- {repo} {dir}"},
+
+	// Without --overwrite bzr will not pull tags that changed.
+	// Replace by --overwrite-tags after http://pad.lv/681792 goes in.
+	DownloadCmd: []string{"pull --overwrite"},
+
+	TagCmd:         []tagCmd{{"tags", `^(\S+)`}},
+	TagSyncCmd:     []string{"update -r {tag}"},
+	TagSyncDefault: []string{"update -r revno:-1"},
+
+	Scheme:      []string{"https", "http", "bzr", "bzr+ssh"},
+	PingCmd:     "info -- {scheme}://{repo}",
+	RemoteRepo:  bzrRemoteRepo,
+	ResolveRepo: bzrResolveRepo,
+	Status:      bzrStatus,
+}
+
+func bzrRemoteRepo(vcsBzr *Cmd, rootDir string) (remoteRepo string, err error) {
+	outb, err := vcsBzr.runOutput(rootDir, "config parent_location")
+	if err != nil {
+		return "", err
+	}
+	return strings.TrimSpace(string(outb)), nil
+}
+
+func bzrResolveRepo(vcsBzr *Cmd, rootDir, remoteRepo string) (realRepo string, err error) {
+	outb, err := vcsBzr.runOutput(rootDir, "info -- "+remoteRepo)
+	if err != nil {
+		return "", err
+	}
+	out := string(outb)
+
+	// Expect:
+	// ...
+	//   (branch root|repository branch): <URL>
+	// ...
+
+	found := false
+	for _, prefix := range []string{"\n  branch root: ", "\n  repository branch: "} {
+		i := strings.Index(out, prefix)
+		if i >= 0 {
+			out = out[i+len(prefix):]
+			found = true
+			break
+		}
+	}
+	if !found {
+		return "", fmt.Errorf("unable to parse output of bzr info")
+	}
+
+	i := strings.Index(out, "\n")
+	if i < 0 {
+		return "", fmt.Errorf("unable to parse output of bzr info")
+	}
+	out = out[:i]
+	return strings.TrimSpace(out), nil
 }
 
 func bzrStatus(vcsBzr *Cmd, rootDir string) (Status, error) {
@@ -336,12 +490,46 @@ var vcsSvn = &Cmd{
 		{filename: ".svn", isDir: true},
 	},
 
+	CreateCmd:   []string{"checkout -- {repo} {dir}"},
+	DownloadCmd: []string{"update"},
+
 	// There is no tag command in subversion.
 	// The branch information is all in the path names.
 
-	Scheme:  []string{"https", "http", "svn", "svn+ssh"},
-	PingCmd: "info -- {scheme}://{repo}",
-	Status:  svnStatus,
+	Scheme:     []string{"https", "http", "svn", "svn+ssh"},
+	PingCmd:    "info -- {scheme}://{repo}",
+	RemoteRepo: svnRemoteRepo,
+	Status:     svnStatus,
+}
+
+func svnRemoteRepo(vcsSvn *Cmd, rootDir string) (remoteRepo string, err error) {
+	outb, err := vcsSvn.runOutput(rootDir, "info")
+	if err != nil {
+		return "", err
+	}
+	out := string(outb)
+
+	// Expect:
+	//
+	//       ...
+	//      URL: <URL>
+	//      ...
+	//
+	// Note that we're not using the Repository Root line,
+	// because svn allows checking out subtrees.
+	// The URL will be the URL of the subtree (what we used with 'svn co')
+	// while the Repository Root may be a much higher parent.
+	i := strings.Index(out, "\nURL: ")
+	if i < 0 {
+		return "", fmt.Errorf("unable to parse output of svn info")
+	}
+	out = out[i+len("\nURL: "):]
+	i = strings.Index(out, "\n")
+	if i < 0 {
+		return "", fmt.Errorf("unable to parse output of svn info")
+	}
+	out = out[:i]
+	return strings.TrimSpace(out), nil
 }
 
 func svnStatus(vcsSvn *Cmd, rootDir string) (Status, error) {
@@ -386,8 +574,24 @@ var vcsFossil = &Cmd{
 		{filename: "_FOSSIL_", isDir: false},
 	},
 
-	Scheme: []string{"https", "http"},
-	Status: fossilStatus,
+	CreateCmd:   []string{"--go-internal-mkdir {dir} clone -- {repo} " + filepath.Join("{dir}", fossilRepoName), "--go-internal-cd {dir} open .fossil"},
+	DownloadCmd: []string{"up"},
+
+	TagCmd:         []tagCmd{{"tag ls", `(.*)`}},
+	TagSyncCmd:     []string{"up tag:{tag}"},
+	TagSyncDefault: []string{"up trunk"},
+
+	Scheme:     []string{"https", "http"},
+	RemoteRepo: fossilRemoteRepo,
+	Status:     fossilStatus,
+}
+
+func fossilRemoteRepo(vcsFossil *Cmd, rootDir string) (remoteRepo string, err error) {
+	out, err := vcsFossil.runOutput(rootDir, "remote-url")
+	if err != nil {
+		return "", err
+	}
+	return strings.TrimSpace(string(out)), nil
 }
 
 var errFossilInfo = errors.New("unable to parse output of fossil info")
@@ -562,6 +766,99 @@ func (v *Cmd) Ping(scheme, repo string) error {
 	return v.runVerboseOnly(dir, v.PingCmd, "scheme", scheme, "repo", repo)
 }
 
+// Create creates a new copy of repo in dir.
+// The parent of dir must exist; dir must not.
+func (v *Cmd) Create(dir, repo string) error {
+	release, err := base.AcquireNet()
+	if err != nil {
+		return err
+	}
+	defer release()
+
+	for _, cmd := range v.CreateCmd {
+		if err := v.run(filepath.Dir(dir), cmd, "dir", dir, "repo", repo); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// Download downloads any new changes for the repo in dir.
+func (v *Cmd) Download(dir string) error {
+	release, err := base.AcquireNet()
+	if err != nil {
+		return err
+	}
+	defer release()
+
+	for _, cmd := range v.DownloadCmd {
+		if err := v.run(dir, cmd); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// Tags returns the list of available tags for the repo in dir.
+func (v *Cmd) Tags(dir string) ([]string, error) {
+	var tags []string
+	for _, tc := range v.TagCmd {
+		out, err := v.runOutput(dir, tc.cmd)
+		if err != nil {
+			return nil, err
+		}
+		re := regexp.MustCompile(`(?m-s)` + tc.pattern)
+		for _, m := range re.FindAllStringSubmatch(string(out), -1) {
+			tags = append(tags, m[1])
+		}
+	}
+	return tags, nil
+}
+
+// TagSync syncs the repo in dir to the named tag,
+// which either is a tag returned by tags or is v.tagDefault.
+func (v *Cmd) TagSync(dir, tag string) error {
+	if v.TagSyncCmd == nil {
+		return nil
+	}
+	if tag != "" {
+		for _, tc := range v.TagLookupCmd {
+			out, err := v.runOutput(dir, tc.cmd, "tag", tag)
+			if err != nil {
+				return err
+			}
+			re := regexp.MustCompile(`(?m-s)` + tc.pattern)
+			m := re.FindStringSubmatch(string(out))
+			if len(m) > 1 {
+				tag = m[1]
+				break
+			}
+		}
+	}
+
+	release, err := base.AcquireNet()
+	if err != nil {
+		return err
+	}
+	defer release()
+
+	if tag == "" && v.TagSyncDefault != nil {
+		for _, cmd := range v.TagSyncDefault {
+			if err := v.run(dir, cmd); err != nil {
+				return err
+			}
+		}
+		return nil
+	}
+
+	for _, cmd := range v.TagSyncCmd {
+		if err := v.run(dir, cmd, "tag", tag); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
 // A vcsPath describes how to convert an import path into a
 // version control system and repository name.
 type vcsPath struct {
@@ -764,11 +1061,11 @@ var defaultGOVCS = govcsConfig{
 	{"public", []string{"git", "hg"}},
 }
 
-// checkGOVCS checks whether the policy defined by the environment variable
+// CheckGOVCS checks whether the policy defined by the environment variable
 // GOVCS allows the given vcs command to be used with the given repository
 // root path. Note that root may not be a real package or module path; it's
 // the same as the root path in the go-import meta tag.
-func checkGOVCS(vcs *Cmd, root string) error {
+func CheckGOVCS(vcs *Cmd, root string) error {
 	if vcs == vcsMod {
 		// Direct module (proxy protocol) fetches don't
 		// involve an external version control system
@@ -796,6 +1093,37 @@ func checkGOVCS(vcs *Cmd, root string) error {
 	return nil
 }
 
+// CheckNested checks for an incorrectly-nested VCS-inside-VCS
+// situation for dir, checking parents up until srcRoot.
+func CheckNested(vcs *Cmd, dir, srcRoot string) error {
+	if len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {
+		return fmt.Errorf("directory %q is outside source root %q", dir, srcRoot)
+	}
+
+	otherDir := dir
+	for len(otherDir) > len(srcRoot) {
+		for _, otherVCS := range vcsList {
+			if isVCSRoot(otherDir, otherVCS.RootNames) {
+				// Allow expected vcs in original dir.
+				if otherDir == dir && otherVCS == vcs {
+					continue
+				}
+				// Otherwise, we have one VCS inside a different VCS.
+				return fmt.Errorf("directory %q uses %s, but parent %q uses %s", dir, vcs.Cmd, otherDir, otherVCS.Cmd)
+			}
+		}
+		// Move to parent.
+		newDir := filepath.Dir(otherDir)
+		if len(newDir) >= len(otherDir) {
+			// Shouldn't happen, but just in case, stop.
+			break
+		}
+		otherDir = newDir
+	}
+
+	return nil
+}
+
 // RepoRoot describes the repository root for a tree of source code.
 type RepoRoot struct {
 	Repo     string // repository URL, including scheme
@@ -912,7 +1240,7 @@ func repoRootFromVCSPaths(importPath string, security web.SecurityMode, vcsPaths
 		if vcs == nil {
 			return nil, fmt.Errorf("unknown version control system %q", match["vcs"])
 		}
-		if err := checkGOVCS(vcs, match["root"]); err != nil {
+		if err := CheckGOVCS(vcs, match["root"]); err != nil {
 			return nil, err
 		}
 		var repoURL string
@@ -1105,7 +1433,7 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se
 		}
 	}
 
-	if err := checkGOVCS(vcs, mmi.Prefix); err != nil {
+	if err := CheckGOVCS(vcs, mmi.Prefix); err != nil {
 		return nil, err
 	}
 
diff --git a/src/cmd/go/main.go b/src/cmd/go/main.go
index 8cdfd91..e9b1149 100644
--- a/src/cmd/go/main.go
+++ b/src/cmd/go/main.go
@@ -26,6 +26,7 @@ import (
 	"cmd/go/internal/envcmd"
 	"cmd/go/internal/fmtcmd"
 	"cmd/go/internal/generate"
+	"cmd/go/internal/get"
 	"cmd/go/internal/help"
 	"cmd/go/internal/list"
 	"cmd/go/internal/modcmd"
@@ -79,9 +80,11 @@ func init() {
 		help.HelpGoAuth,
 		modload.HelpGoMod,
 		help.HelpGopath,
+		get.HelpGopathGet,
 		modfetch.HelpGoproxy,
 		help.HelpImportPath,
 		modload.HelpModules,
+		modget.HelpModuleGet,
 		modfetch.HelpModuleAuth,
 		help.HelpPackages,
 		modfetch.HelpPrivate,
@@ -118,6 +121,14 @@ func main() {
 		base.Usage()
 	}
 
+	if args[0] == "get" || args[0] == "help" {
+		s := modload.NewState()
+		if !s.WillBeEnabled() {
+			// Replace module-aware get with GOPATH get if appropriate.
+			*modget.CmdGet = *get.CmdGet
+		}
+	}
+
 	cfg.CmdName = args[0] // for error messages
 	if args[0] == "help" {
 		counter.Inc("go/subcommand:" + strings.Join(append([]string{"help"}, args[1:]...), "-"))
diff --git a/src/cmd/internal/par/work.go b/src/cmd/internal/par/work.go
index 881b51b..3f1e69a 100644
--- a/src/cmd/internal/par/work.go
+++ b/src/cmd/internal/par/work.go
@@ -180,3 +180,41 @@ func (c *Cache[K, V]) Get(key K) (V, bool) {
 	}
 	return e.result, true
 }
+
+// Clear removes all entries in the cache.
+//
+// Concurrent calls to Get may return old values. Concurrent calls to Do
+// may return old values or store results in entries that have been deleted.
+//
+// TODO(jayconrod): Delete this after the package cache clearing functions
+// in internal/load have been removed.
+func (c *Cache[K, V]) Clear() {
+	c.m.Clear()
+}
+
+// Delete removes an entry from the map. It is safe to call Delete for an
+// entry that does not exist. Delete will return quickly, even if the result
+// for a key is still being computed; the computation will finish, but the
+// result won't be accessible through the cache.
+//
+// TODO(jayconrod): Delete this after the package cache clearing functions
+// in internal/load have been removed.
+func (c *Cache[K, V]) Delete(key K) {
+	c.m.Delete(key)
+}
+
+// DeleteIf calls pred for each key in the map. If pred returns true for a key,
+// DeleteIf removes the corresponding entry. If the result for a key is
+// still being computed, DeleteIf will remove the entry without waiting for
+// the computation to finish. The result won't be accessible through the cache.
+//
+// TODO(jayconrod): Delete this after the package cache clearing functions
+// in internal/load have been removed.
+func (c *Cache[K, V]) DeleteIf(pred func(key K) bool) {
+	c.m.Range(func(key, _ any) bool {
+		if key := key.(K); pred(key) {
+			c.Delete(key)
+		}
+		return true
+	})
+}
-- 
2.47.3

