From c259400a22270cff03774543ec30f3167cf1e637 Mon Sep 17 00:00:00 2001
From: Vorapol Rinsatitnon <vorapol.r@pm.me>
Date: Thu, 12 Feb 2026 03:20:02 +0700
Subject: [PATCH] Add back LoadLibraryA fallback

---
 src/runtime/os_windows.go       | 49 ++++++++++++++++++++++++++++++--
 src/syscall/dll_windows.go      | 50 ++++++++++++++++++++++++++++++---
 src/syscall/security_windows.go |  1 +
 src/syscall/zsyscall_windows.go | 10 +++++++
 4 files changed, 103 insertions(+), 7 deletions(-)

diff --git a/src/runtime/os_windows.go b/src/runtime/os_windows.go
index f8e7c82..2c5d22e 100644
--- a/src/runtime/os_windows.go
+++ b/src/runtime/os_windows.go
@@ -41,6 +41,7 @@ const (
 //go:cgo_import_dynamic runtime._GetThreadContext GetThreadContext%2 "kernel32.dll"
 //go:cgo_import_dynamic runtime._SetThreadContext SetThreadContext%2 "kernel32.dll"
 //go:cgo_import_dynamic runtime._LoadLibraryExW LoadLibraryExW%3 "kernel32.dll"
+//go:cgo_import_dynamic runtime._LoadLibraryA LoadLibraryA%1 "kernel32.dll"
 //go:cgo_import_dynamic runtime._PostQueuedCompletionStatus PostQueuedCompletionStatus%4 "kernel32.dll"
 //go:cgo_import_dynamic runtime._QueryPerformanceCounter QueryPerformanceCounter%1 "kernel32.dll"
 //go:cgo_import_dynamic runtime._QueryPerformanceFrequency QueryPerformanceFrequency%1 "kernel32.dll"
@@ -74,6 +75,7 @@ var (
 	// Following syscalls are available on every Windows PC.
 	// All these variables are set by the Windows executable
 	// loader before the Go program starts.
+	_AddDllDirectory,
 	_AddVectoredContinueHandler,
 	_AddVectoredExceptionHandler,
 	_CloseHandle,
@@ -98,6 +100,7 @@ var (
 	_GetThreadContext,
 	_SetThreadContext,
 	_LoadLibraryExW,
+	_LoadLibraryA,
 	_PostQueuedCompletionStatus,
 	_QueryPerformanceCounter,
 	_QueryPerformanceFrequency,
@@ -156,7 +159,6 @@ var (
 	ntdlldll    = [...]uint16{'n', 't', 'd', 'l', 'l', '.', 'd', 'l', 'l', 0}
 	powrprofdll = [...]uint16{'p', 'o', 'w', 'r', 'p', 'r', 'o', 'f', '.', 'd', 'l', 'l', 0}
 	winmmdll    = [...]uint16{'w', 'i', 'n', 'm', 'm', '.', 'd', 'l', 'l', 0}
-	ws2_32dll   = [...]uint16{'w', 's', '2', '_', '3', '2', '.', 'd', 'l', 'l', 0}
 )
 
 // Function to be called by windows CreateThread
@@ -251,8 +253,37 @@ func windows_GetSystemDirectory() string {
 }
 
 func windowsLoadSystemLib(name []uint16) uintptr {
-	const _LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
-	return stdcall(_LoadLibraryExW, uintptr(unsafe.Pointer(&name[0])), 0, _LOAD_LIBRARY_SEARCH_SYSTEM32)
+	if useLoadLibraryEx {
+		const _LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
+		return stdcall(_LoadLibraryExW, uintptr(unsafe.Pointer(&name[0])), 0, _LOAD_LIBRARY_SEARCH_SYSTEM32)
+	} else {
+		var nameBytes [_MAX_PATH]byte
+		n := len(name)
+		if n > len(nameBytes) {
+			n = len(nameBytes)
+		}
+		for i := 0; i < n && name[i] != 0; i++ {
+			nameBytes[i] = byte(name[i])
+		}
+
+		// Construct the full path
+		var fullPath [_MAX_PATH]byte
+		copy(fullPath[:], sysDirectory[:sysDirectoryLen])
+		pathLen := sysDirectoryLen
+		for i := 0; i < len(nameBytes) && nameBytes[i] != 0 && pathLen < _MAX_PATH; i++ {
+			fullPath[pathLen] = nameBytes[i]
+			pathLen++
+		}
+
+		// Ensure null-termination
+		if pathLen < _MAX_PATH {
+			fullPath[pathLen] = 0
+		} else {
+			fullPath[_MAX_PATH-1] = 0
+		}
+
+		return stdcall(_LoadLibraryA, uintptr(unsafe.Pointer(&fullPath[0])))
+	}
 }
 
 //go:linkname windows_QueryPerformanceCounter internal/syscall/windows.QueryPerformanceCounter
@@ -270,6 +301,15 @@ func windows_QueryPerformanceFrequency() int64 {
 }
 
 func loadOptionalSyscalls() {
+	var kernel32dll = []byte("kernel32.dll\000")
+	k32 := stdcall(_LoadLibraryA, uintptr(unsafe.Pointer(&kernel32dll[0])))
+	if k32 == 0 {
+		throw("kernel32.dll not found")
+	}
+	_AddDllDirectory = windowsFindfunc(k32, []byte("AddDllDirectory\000"))
+	_LoadLibraryExW = windowsFindfunc(k32, []byte("LoadLibraryExW\000"))
+	useLoadLibraryEx = (_LoadLibraryExW != nil && _AddDllDirectory != nil)
+
 	a32 := windowsLoadSystemLib(advapi32dll[:])
 	if a32 == 0 {
 		throw("advapi32.dll not found")
@@ -359,6 +399,9 @@ func getPageSize() uintptr {
 // in sys_windows_386.s and sys_windows_amd64.s:
 func getlasterror() uint32
 
+//go:linkname useLoadLibraryEx syscall.useLoadLibraryEx
+var useLoadLibraryEx bool
+
 var timeBeginPeriodRetValue uint32
 
 // osRelaxMinNS indicates that sysmon shouldn't osRelax if the next
diff --git a/src/syscall/dll_windows.go b/src/syscall/dll_windows.go
index 9d77986..adfae1f 100644
--- a/src/syscall/dll_windows.go
+++ b/src/syscall/dll_windows.go
@@ -13,10 +13,12 @@ import (
 
 // Use double underscore to avoid name collision autogenerated functions.
 //go:cgo_import_dynamic syscall.__LoadLibraryExW LoadLibraryExW%3 "kernel32.dll"
+//go:cgo_import_dynamic syscall.__LoadLibraryW LoadLibraryW%1 "kernel32.dll"
 //go:cgo_import_dynamic syscall.__GetProcAddress GetProcAddress%2 "kernel32.dll"
 
 var (
 	__LoadLibraryExW unsafe.Pointer
+	__LoadLibraryW   unsafe.Pointer
 	__GetProcAddress unsafe.Pointer
 )
 
@@ -109,6 +111,11 @@ func syscalln(fn, n uintptr, args ...uintptr) (r1, r2 uintptr, err Errno)
 // //go:linkname to act as an allowlist for linker's -checklinkname, as
 // golang.org/x/sys/windows linknames these functions.
 
+// Link to runtime's useLoadLibraryEx variable
+//
+//go:linkname useLoadLibraryEx runtime.useLoadLibraryEx
+var useLoadLibraryEx bool
+
 //go:linkname loadlibrary
 func loadlibrary(filename *uint16) (uintptr, Errno) {
 	handle, _, err := SyscallN(uintptr(__LoadLibraryExW), uintptr(unsafe.Pointer(filename)), 0, 0)
@@ -119,9 +126,20 @@ func loadlibrary(filename *uint16) (uintptr, Errno) {
 }
 
 //go:linkname loadsystemlibrary
-func loadsystemlibrary(filename *uint16) (uintptr, Errno) {
-	const _LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
-	handle, _, err := SyscallN(uintptr(__LoadLibraryExW), uintptr(unsafe.Pointer(filename)), 0, _LOAD_LIBRARY_SEARCH_SYSTEM32)
+func loadsystemlibrary(filename *uint16, absoluteFilepath *uint16) (uintptr, Errno) {
+	var handle uintptr
+	var err Errno
+
+	if useLoadLibraryEx {
+		const _LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
+		handle, _, err = SyscallN(uintptr(__LoadLibraryExW), uintptr(unsafe.Pointer(filename)), 0, _LOAD_LIBRARY_SEARCH_SYSTEM32)
+	} else {
+		handle, _, err = SyscallN(
+			uintptr(__LoadLibraryW),
+			uintptr(unsafe.Pointer(absoluteFilepath)),
+		)
+	}
+
 	if handle != 0 {
 		err = 0
 	}
@@ -143,6 +161,26 @@ type DLL struct {
 	Handle Handle
 }
 
+// We use this for computing the absolute path for system DLLs on systems
+// where SEARCH_SYSTEM32 is not available.
+var systemDirectoryPrefix string
+
+func init() {
+	n := uint32(MAX_PATH)
+	for {
+		b := make([]uint16, n)
+		l, e := getSystemDirectory(&b[0], n)
+		if e != nil {
+			panic("Unable to determine system directory: " + e.Error())
+		}
+		if l <= n {
+			systemDirectoryPrefix = UTF16ToString(b[:l]) + "\\"
+			break
+		}
+		n = l
+	}
+}
+
 // LoadDLL loads the named DLL file into memory.
 //
 // If name is not an absolute path and is not a known system DLL used by
@@ -159,7 +197,11 @@ func LoadDLL(name string) (*DLL, error) {
 	var h uintptr
 	var e Errno
 	if sysdll.IsSystemDLL[name] {
-		h, e = loadsystemlibrary(namep)
+		absoluteFilepathp, err := UTF16PtrFromString(systemDirectoryPrefix + name)
+		if err != nil {
+			return nil, err
+		}
+		h, e = loadsystemlibrary(namep, absoluteFilepathp)
 	} else {
 		h, e = loadlibrary(namep)
 	}
diff --git a/src/syscall/security_windows.go b/src/syscall/security_windows.go
index 4e988c4..45b1908 100644
--- a/src/syscall/security_windows.go
+++ b/src/syscall/security_windows.go
@@ -290,6 +290,7 @@ type Tokenprimarygroup struct {
 //sys	OpenProcessToken(h Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken
 //sys	GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation
 //sys	GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW
+//sys	getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) = kernel32.GetSystemDirectoryW
 
 // An access token contains the security information for a logon session.
 // The system creates an access token when a user logs on, and every
diff --git a/src/syscall/zsyscall_windows.go b/src/syscall/zsyscall_windows.go
index 70ac19a..aec4b2d 100644
--- a/src/syscall/zsyscall_windows.go
+++ b/src/syscall/zsyscall_windows.go
@@ -128,6 +128,7 @@ var (
 	procGetShortPathNameW                  = modkernel32.NewProc("GetShortPathNameW")
 	procGetStartupInfoW                    = modkernel32.NewProc("GetStartupInfoW")
 	procGetStdHandle                       = modkernel32.NewProc("GetStdHandle")
+	procGetSystemDirectoryW                = modkernel32.NewProc("GetSystemDirectoryW")
 	procGetSystemTimeAsFileTime            = modkernel32.NewProc("GetSystemTimeAsFileTime")
 	procGetTempPathW                       = modkernel32.NewProc("GetTempPathW")
 	procGetTimeZoneInformation             = modkernel32.NewProc("GetTimeZoneInformation")
@@ -872,6 +873,15 @@ func GetStdHandle(stdhandle int) (handle Handle, err error) {
 	return
 }
 
+func getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {
+	r0, _, e1 := Syscall(procGetSystemDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
+	len = uint32(r0)
+	if len == 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
 func GetSystemTimeAsFileTime(time *Filetime) {
 	SyscallN(procGetSystemTimeAsFileTime.Addr(), uintptr(unsafe.Pointer(time)))
 	return
-- 
2.47.3

